/*!
# Refract: Images
*/

use dowser::Extension;
use iced::{
	widget::image,
	window::{
		Icon,
		icon,
	},
};
use refract_core::ImageKind;
use std::path::{
	Path,
	PathBuf,
};



// The E_AVIF, E_JPEG, E_JPG, E_JXL, E_PNG, and E_WEBP constants are generated
// by build.rs.
include!(concat!(env!("OUT_DIR"), "/refract-extensions.rs"));

// The image helpers for icons, logos, checkboards, etc., are likewise
// generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/refract-img.rs"));



/// # Is JPEG/PNG File.
pub(super) fn is_jpeg_png(path: &Path) -> bool {
	Extension::try_from3(path).map_or_else(
		|| Extension::try_from4(path) == Some(E_JPEG),
		|e| e == E_JPG || e == E_PNG
	)
}

/// # Fix Path Extension.
pub(super) fn with_ng_extension(mut path: PathBuf, kind: ImageKind) -> PathBuf {
	let ext = match kind {
		ImageKind::Avif =>
			if Extension::try_from4(&path) == Some(E_AVIF) { return path; }
			else { ".avif" },
		ImageKind::Jxl =>
			if Extension::try_from3(&path) == Some(E_JXL) { return path; }
			else { ".jxl" },
		ImageKind::Webp =>
			if Extension::try_from4(&path) == Some(E_WEBP) { return path; }
			else { ".webp" },
		ImageKind::Jpeg =>
			if Extension::try_from3(&path).map_or_else(
				|| Extension::try_from4(&path) == Some(E_JPEG),
				|e| e == E_JPG
			) { return path; }
			else { ".jpg" },
		ImageKind::Png =>
			if Extension::try_from3(&path) == Some(E_PNG) { return path; }
			else { ".png" },
	};

	// Append and return.
	path.as_mut_os_string().push(ext);
	path
}



#[expect(clippy::cast_possible_truncation, reason = "False positive.")]
/// # Tiled Checkboard Tiles.
///
/// This method is a workaround for the lack of repeating-background support
/// in `iced`.
///
/// Our checkboard images need to be big enough to fill (most) screens — 8K is
/// where we settled — but are thus _too big_ to directly embed into the binary
/// as bitmaps.
///
/// The patterns themselves are only 60x60 pixels, so we embed those instead
/// and manually construct the wallpapers at runtime.
///
/// Not ideal, but the overhead isn't actually too bad, and at any rate only
/// occurs once since the results are cached.
fn tile_checkers(tile: &[u8; 14_400]) -> image::Handle {
	/// # Tile Dimensions (pixels).
	const TILE: usize = 60;

	/// # Output Width (pixels).
	const WIDTH: usize = 7680;

	/// # Output Height (pixels).
	const HEIGHT: usize = 4320;

	// First things first, let's repeat the entire tile once, width-wise,
	// since the broken-up writes aren't terribly performant.
	let mut pixels = Vec::<u8>::with_capacity(WIDTH * HEIGHT * 4);
	for line in tile.chunks_exact(TILE * 4) {
		for _ in 0..WIDTH / TILE { pixels.extend_from_slice(line); }
	}

	// To complete the picture, we just need to copy that first block en masse
	// (height / 60 - 1) times.
	for _ in 0..(HEIGHT / TILE) - 1 { pixels.extend_from_within(..WIDTH * TILE * 4); }

	// Make sure we got the math right.
	debug_assert!(
		pixels.len() == WIDTH * HEIGHT * 4,
		"BUG: the checkboard has the wrong dimensions!",
	);

	// Done!
	image::Handle::from_rgba(WIDTH as u32, HEIGHT as u32, pixels)
}
