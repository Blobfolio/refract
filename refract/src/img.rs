/*!
# Refract: Images
*/

use dowser::Extension;
use iced::{
	widget::image,
	window::{
		Icon,
		icon,
	},
};
use refract_core::ImageKind;
use std::path::{
	Path,
	PathBuf,
};



/// # Extension: AVIF.
const E_AVIF: Extension = Extension::new("avif").unwrap();

/// # Extension: JPEG.
const E_JPEG: Extension = Extension::new("jpeg").unwrap();

/// # Extension: JPG.
const E_JPG: Extension = Extension::new("jpg").unwrap();

/// # Extension: JXL.
const E_JXL: Extension = Extension::new("jxl").unwrap();

/// # Extension: PNG.
const E_PNG: Extension = Extension::new("png").unwrap();

/// # Extension: WEBP.
const E_WEBP: Extension = Extension::new("webp").unwrap();

// The image helpers for icons, logos, checkboards, etc., are likewise
// generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/refract-img.rs"));



/// # Is JPEG/PNG File.
pub(super) fn is_jpeg_png(path: &Path) -> bool {
	matches!(Extension::from_path(path), Some(E_JPEG | E_JPG | E_PNG))
}

/// # Fix Path Extension.
pub(super) fn with_ng_extension(path: &Path, kind: ImageKind) -> Option<PathBuf> {
	// The path can't be gibberish; we need a valid parent directory and a
	// file name.
	let mut out = path.parent().and_then(|p| std::fs::canonicalize(p).ok())?;
	out.push(path.file_name()?);

	// Check the extension, though; we may need to add our own on top.
	let ext = match kind {
		ImageKind::Avif =>
			if E_AVIF.matches_path(&out) { return Some(out); }
			else { ".avif" },
		ImageKind::Jxl =>
			if E_JXL.matches_path(&out) { return Some(out); }
			else { ".jxl" },
		ImageKind::Webp =>
			if E_WEBP.matches_path(&out) { return Some(out); }
			else { ".webp" },
		ImageKind::Jpeg =>
			if matches!(Extension::from_path(&out), Some(E_JPEG | E_JPG)) { return Some(out); }
			else { ".jpg" },
		ImageKind::Png =>
			if E_PNG.matches_path(&out) { return Some(out); }
			else { ".png" },
		ImageKind::Invalid => return None,
	};

	// Append and return!
	out.as_mut_os_string().push(ext);
	Some(out)
}



#[expect(clippy::cast_possible_truncation, reason = "False positive.")]
/// # Tiled Checkboard Tiles.
///
/// This method is a workaround for the lack of repeating-background support
/// in `iced`.
///
/// Our checkboard images need to be big enough to fill (most) screens — 8K is
/// where we settled — but are thus _too big_ to directly embed into the binary
/// as bitmaps.
///
/// The patterns themselves are only 60x60 pixels, so we embed those instead
/// and manually construct the wallpapers at runtime.
///
/// Not ideal, but the overhead isn't actually too bad, and at any rate only
/// occurs once since the results are cached.
fn tile_checkers(tile: &[u8; 14_400]) -> image::Handle {
	/// # Tile Dimensions (pixels).
	const TILE: usize = 60;

	/// # Output Width (pixels).
	const WIDTH: usize = 7680;

	/// # Output Height (pixels).
	const HEIGHT: usize = 4320;

	// First things first, let's repeat the entire tile once, width-wise,
	// since the broken-up writes aren't terribly performant.
	let mut pixels = Vec::<u8>::with_capacity(WIDTH * HEIGHT * 4);
	for line in tile.chunks_exact(TILE * 4) {
		for _ in 0..WIDTH / TILE { pixels.extend_from_slice(line); }
	}

	// To complete the picture, we just need to copy that first block en masse
	// (height / 60 - 1) times.
	for _ in 0..(HEIGHT / TILE) - 1 { pixels.extend_from_within(..WIDTH * TILE * 4); }

	// Make sure we got the math right.
	debug_assert!(
		pixels.len() == WIDTH * HEIGHT * 4,
		"BUG: the checkboard has the wrong dimensions!",
	);

	// Done!
	image::Handle::from_rgba(WIDTH as u32, HEIGHT as u32, pixels)
}
